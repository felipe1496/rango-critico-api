// src/constants.ts
var operators = {
  eq: "=",
  ne: "!=",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  in: "IN",
  nin: "NOT IN",
  like: "LIKE",
  nlike: "NOT LIKE",
  sw: "LIKE",
  ew: "LIKE",
  is: "IS",
  isn: "IS NOT"
};

// src/condition.ts
function validateInputOperator(op) {
  if (!operators[op]) {
    throw new Error(
      `Invalid operator ${op}, allowed operators are ${Object.keys(
        operators
      ).join(", ")}`
    );
  }
}
function validateInputOperatorToValue(op, value) {
  switch (op) {
    case "in":
    case "nin":
      if (!Array.isArray(value)) {
        throw new Error(`Value must be an array for ${op} operator`);
      }
      break;
    case "like":
    case "nlike":
    case "sw":
    case "ew":
      if (typeof value !== "string") {
        throw new Error(`Value must be string for ${op} operator`);
      }
      break;
    case "eq":
    case "ne":
    case "gt":
    case "gte":
    case "lt":
    case "lte":
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Value must be string or number for ${op} operator`);
      }
      break;
    case "is":
    case "isn":
      if (typeof value !== "boolean" && value !== null) {
        throw new Error(`Value must be boolean or null for ${op} operator`);
      }
      break;
    default:
      break;
  }
}
function getSqlPlaceholder(op, value) {
  switch (op) {
    case "like":
    case "nlike":
    case "sw":
    case "ew":
      return "upper(?)";
    case "in":
    case "nin":
      return `(${value.map(() => "?").join(", ")})`;
    default:
      return "?";
  }
}
function getField(field, op) {
  switch (op) {
    case "like":
    case "nlike":
    case "sw":
    case "ew":
      return `upper("${field}")`;
    default:
      return `"${field}"`;
  }
}
function getValue(value, op) {
  switch (op) {
    case "like":
    case "nlike":
      return `%${value}%`;
    case "sw":
      return `${value}%`;
    case "ew":
      return `%${value}`;
    default:
      return value;
  }
}
function createCondition(field, operator, value) {
  validateInputOperator(operator);
  validateInputOperatorToValue(operator, value);
  return {
    field,
    operator,
    value
  };
}
function parseConditionSQL({ field, operator, value }) {
  const sql = `${getField(field, operator)} ${operators[operator]} ${getSqlPlaceholder(operator, value)}`;
  return {
    sql,
    value: getValue(value, operator)
  };
}

// src/utils.ts
function escapeStr(str) {
  if (str.startsWith("'") && str.endsWith("'")) {
    return str.slice(1, -1).replace(/''/g, "'");
  }
  return str;
}

// src/parse-string-to-where.ts
function getValue2(value, op) {
  console.log("value: ", value, op);
  switch (op) {
    case "is":
    case "isn":
      if (value.toLowerCase() === "null") return null;
      if (value.toLowerCase() === "true") return true;
      if (value.toLowerCase() === "false") return false;
      break;
    case "eq":
    case "ne":
    case "lt":
    case "lte":
    case "gt":
    case "gte":
    case "like":
    case "nlike":
    case "sw":
    case "ew":
      const isString = value.startsWith("'") && value.endsWith("'");
      if (isString) {
        return escapeStr(value);
      } else {
        const num = Number(value);
        if (!isNaN(num)) {
          return num;
        }
      }
      break;
    case "in":
    case "nin":
      if (value.startsWith("(") && value.endsWith(")")) {
        console.log("entrei aqui", value);
        const _value = value.slice(1, -1).split(",").map((v) => {
          const _v = v.trim();
          const isString2 = _v.startsWith("'") && _v.endsWith("'");
          if (isString2) {
            return escapeStr(_v);
          } else {
            const num = Number(_v);
            if (!isNaN(num)) {
              return num;
            }
          }
        });
        return _value;
      }
      break;
    default:
      return value;
  }
}
function parseStringToWhere(str) {
  const resultWhere = where();
  const andSplitted = str.split(" and ");
  if (!andSplitted.length) {
    return resultWhere;
  }
  andSplitted.forEach((c) => {
    const isOr = c.startsWith("(") && c.endsWith(")") && c.includes(" or ");
    if (isOr) {
      const strOrConds = c.slice(1, -1).split(" or ");
      const orConditions = strOrConds.map(
        (orCond) => {
          const parts = str.split(" ");
          if (parts.length < 3) {
            throw new Error(`Invalid condition: ${orCond}`);
          }
          const [field, operator, value] = [
            parts[0],
            parts[1],
            parts[2],
            parts.slice(3).join(" ")
          ];
          return [
            field,
            operator,
            getValue2(value, operator)
          ];
        }
      );
      resultWhere.or(orConditions);
    } else {
      const parts = c.split(" ");
      if (parts.length < 3) {
        throw new Error(`Invalid condition: ${c}`);
      }
      const [field, operator, value] = [
        parts[0],
        parts[1],
        parts.slice(2).join(" ")
      ];
      console.log("parts: ", field, operator, value);
      resultWhere.and(
        field,
        operator,
        getValue2(value, operator)
      );
    }
  });
  return resultWhere;
}

// src/where.ts
function where(str) {
  if (str) {
    return parseStringToWhere(str);
  }
  let pageValue = 1;
  let perPageValue = 201;
  const conds = [];
  function and(field, operator, value) {
    conds.push(createCondition(field, operator, value));
    return {
      and,
      or,
      build,
      page,
      perPage,
      pageValue,
      perPageValue
    };
  }
  function or(orConditions) {
    conds.push(
      orConditions.map(
        ([field, operator, value]) => createCondition(field, operator, value)
      )
    );
    return {
      and,
      or,
      build,
      page,
      perPage,
      pageValue,
      perPageValue
    };
  }
  function page(newPage) {
    if (newPage <= 0) {
      throw new Error("Page must be greater than 0");
    }
    pageValue = newPage;
    return {
      and,
      or,
      build,
      page,
      perPage,
      pageValue,
      perPageValue
    };
  }
  function perPage(newPerPage) {
    if (newPerPage <= 0) {
      throw new Error("PerPage must be greater than 0");
    }
    perPageValue = newPerPage;
    return {
      and,
      or,
      build,
      page,
      perPage,
      pageValue,
      perPageValue
    };
  }
  function build() {
    const parsed = conds.map((c) => {
      if (Array.isArray(c)) {
        const orConditions = c.map((orCond) => parseConditionSQL(orCond));
        return {
          sql: `(${orConditions.map((orCond) => orCond.sql).join(" OR ")})`,
          value: orConditions.map((orCond) => orCond.value)
        };
      } else {
        return parseConditionSQL(c);
      }
    });
    let sql = "1 = 1";
    if (parsed.length) {
      sql += ` AND ${parsed.map((p) => p.sql).join(" AND ")}`;
    }
    sql += ` LIMIT ? OFFSET ?`;
    return {
      sql,
      values: [
        ...parsed.map((p) => p.value).flat(Infinity),
        perPageValue,
        (pageValue - 1) * perPageValue
      ]
    };
  }
  return {
    and,
    or,
    build,
    page,
    perPage,
    pageValue,
    perPageValue
  };
}
export {
  where
};
